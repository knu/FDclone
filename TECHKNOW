[FDclone に関するテクニカルノウハウ集]


1.機種依存性吸収のために用意されている識別子

　mashine.h の中や、make config で生成される config.h の中で
は、各種の識別子が定義されています。これらの識別子は、OS の
違いを吸収するために設けられています。
　自分の環境で、うまくコンパイルできない、どうもおかしな挙動
を示すというような場合には、これらの識別子を定義したり、定義
を取り消したりして調整して下さい。
　各識別子の意味を以下に列挙します。

SYSV
SVR4
BSD4
BSD43	各種 OS の元となるタイプを示します。SYSV, SVR4 は、
	mashine.h の後半で、OS 特有の定義のために参照されて
	いますが、BSD4, BSD43 は、参考として定義されているだ
	けなので、実際にはソース中で参照されていません。

OSTYPE	各 OS を表す識別子を定義しています。フロッピードライ
	ブのデフォルト設定を OS に応じて行なうために使用され
	ています。

CODEEUC	漢字コードとして、EUC(Extended Unix Code) を用います。
	未定義の場合は ShiftJIS になります。インストール後の
	man ページや、ファイル名として用いる漢字コード等に影
	響します。
	出入力に関しては、コンパイル後に動的に変更可能です。
TARUSESPACE
	tar(1) の t オプションの出力の際に、各行のファイルモ
	ード文字列 (Ex:rw-rw-rw-) の直後に必ず空白が入ってい
	る場合に定義します。BSD 系の OS では、空白がなく直後
	に UID/GID が続く場合が多いようです。GNU tar では空
	白が入ります。
	ここで仮に定義を間違えたとしても、.fdrc や /etc/fdrc
	の記述で動的に変更することは可能です。
CPP7BIT	cpp(1) が、漢字などの 8bit 文字を通すことができませ
	ん。
CCCOMMAND
	標準として用いるべき c コンパイラのフルパスを定義し
	ます。一部の OS では、BSD 版 cc と SYSV 版 cc が混在
	することがありますので、どちらかに統一しておきましょ
	う。未定義の場合には cc が用いられます。
EXTENDCCOPT
	cc(1) に与えるオプションを定義します。未定義の場合は
	"-O" が指定されます。"-O"(Optimize) に未対応の場合に
	は、ヌルを定義しておきましょう。
TERMCAPLIB
	tarmcap(5) ライブラリとしてリンクしなくてはならない
	ライブラリを定義します。未定義の場合は -ltermcap が
	指定されます。
REGEXPLIB
	正規表現ライブラリとしてリンクしなければならないライ
	ブラリがある場合定義します。
EXTENDLIB
	その他追加でリンクしなくてはならないライブラリがある
	場合定義します。

UNKNOWNFS
	FDclone が想定している以外のファイルシステムを OS が
	採用しています。その他、ディレクトリ書込み機能がうま
	く実現できない場合にも、安全のため定義しておきます。
	詳細は 2. の項目を参照して下さい。

USELEAPCNT
	OS が、タイムゾーン情報として閏秒を採用しています。
NOVOID	void 型を用いることができません。
NOUID_T	uid_t, gid_t が <sys/types.h> で定義されていません。
DECLERRLIST
	大域変数 sys_errlist[] が <stdio.h> の中で宣言されて
	おり、ソースリスト中で改めて宣言する必要がありません。
PWNEEDERROR
	/lib/libPW.a をリンクする際に、大域変数 Error[] をソ
	ース中に用意しなくてはなりません。
NOERRNO	大域変数 errno が <errno.h> の中で宣言されていません。
NOFILEMODE
	ファイルモードを示す定数 S_IRUSR, S_IWUSR 等が <sys/
	stat.h> の中で定義されていません。
NOUNISTDH
	<unistd.h> が存在しません。
NOSTDLIBH
	<stdlib.h> が存在しません。
USESELECTH
	関数 select(2) を利用する際に必要な構造体 fd_set が、
	<sys/select.h> の中で定義されています。
USESYSDIRH
	ディレクトリファイルのブロックを示す定数 DEV_BSIZE
	が、<sys/dir.h> の中で定義されています。
USETIMEH
	構造体 tm が、<sys/types.h> や <sys/time.h> を参照す
	るだけでは定義されず、<time.h> が必要です。
USETERMIO
	端末インタフェースとして、termio 構造体を用います。
	未定義の場合には sgttyb 構造体を用います。
USEDIRECT
	構造体 dirent の代わりに direct を用います。
SYSVDIRENT
	構造体 dirent がメンバ d_fileno を持たず d_ino を持
	ちます。
NODNAMLEN
	構造体 dirent がメンバ d_namlen を持ちません。
HAVETIMEZONE
	大域変数 timezone が GMT からのオフセット値を表しま
	す。
NOTMGMTOFF
	構造体 tm がメンバ tm_gmtoff を持ちません。

(以下の 5 つは排他的です。同時に複数定義できません。)
USESTATVFSH
	ファイルシステム情報を得るために、<sys/statvfs.h> で
	宣言されている関数群を用います。
USESTATFSH
	ファイルシステム情報を得るために、<sys/statfs.h> で
	宣言されている関数群を用います。
USEVFSH
	ファイルシステム情報を得るために、<sys/vfs.h> で宣言
	されている関数群を用います。
USEMOUNTH
	ファイルシステム情報を得るために、<sys/mount.h> で宣
	言されている関数群を用います。
USEFSDATA
	ファイルシステム情報を得るために、構造体 fs_data を
	用いる関数群を用います。

USEFFSIZE
	構造体 statfs のメンバの中で、ファイルシステムのブロ
	ックサイズとして f_fsize を参照します。未定義の場合
	は f_bsize を参照します。
	USESTATVFSH, USEFSDATA を定義した場合は意味を持ちま
	せん。
STATFSARGS
	関数 statfs(2) の用いる引数の数を定義します。
	USESTATVFSH, USEFSDATA を定義した場合は意味を持ちま
	せん。

(以下の 8 つは排他的です。同時に複数定義できません。)
USEMNTENTH
	マウント情報を得るために、<mntent.h> で宣言されてい
	る関数群を用います。
USEMNTTABH
	マウント情報を得るために、<sys/mnttab.h> で宣言され
	ている関数群を用います。
USEGETFSSTAT
	マウント情報を得るために、関数 getfsstat(3) を用いま
	す。
USEMNTCTL
	マウント情報を得るために、関数 mntctl(3) を用います。
USEMNTINFOR
	マウント情報を得るために、関数 germntinfo_r(3) を用
	います。
USEMNTINFO
	マウント情報を得るために、関数 getmntinfo(3) を用い
	ます。
USEGETMNT
	マウント情報を得るために、関数 getmnt(3) を用います。
USEGETFSENT
	マウント情報を得るために、関数 getfsent(3) を用いま
	す。
	(この手法はマウント前の情報を取得してしまうのでお奨
	めできません。窮余の策だと思って下さい。)

(以下の 2 つは排他的です。同時に複数定義できません。上記の 8
つの選択肢のうち USEMNTINFO 以外を定義した場合は意味を持ちま
せん。)
USEVFCNAME
	構造体 vfsconf のメンバの中で、マウントタイプを表す
	文字列として vfc_name を参照します。また、vfsconf 型
	の取得に getvfsbytype() を用います。
USEFFSTYPE
	構造体 statfs のメンバの中で、マウントタイプを表す文
	字列として f_fstypename を参照します。

(以下の 3 つは排他的です。同時に複数定義できません。)
USERE_COMP
	正規表現検索のために関数 re_comp(3) を用います。
USEREGCOMP
	正規表現検索のために関数 regcomp(3) を用います。
USEREGCMP
	正規表現検索のために関数 regcmp(3) を用います。

USERAND48
	乱数発生用関数として random(3) ではなく rand48(3) を
	用います。
USESETENV
	環境変数設定用関数として setenv(3) が使えます。
NOSELECT
	低レベル入出力関数 select(2) を使うことができません。
NOVSPRINTF
	書式付出力関数 vsprintf(3) を使うことができません。
USEUTIME
	タイムスタンプ設定関数として utimes(2) を用いられず、
	代わりに utime(3) を用います。
USEGETWD
	カレントディレクトリ検査関数として、getcwd(3) を用い
	られず、代わりに getwd(3) を用います。
SIGARGINT
	ソフトウェアシグナル関数 signal(3) の第 2 引数として、
	int 型を返す関数へのポインタが用いられます。

SENSEPERSEC
	1 秒間にキー入力を関知する回数を指定します。端末通信
	速度の遅い場合に定義すると良いでしょう。デフォルトは
	50 回です。
WAITKEYPAD
	ESC キーコードの入力を受けてから待つ時間です。端末通
	信速度の遅い場合に定義すると良いでしょう。デフォルト
	は 360ms です。


2.ディレクトリ書込み機能

　コマンド WRITE_DIR (w) を用いることで、FDclone の表示ディ
レクトリの並びをそのままファイルシステムに書込むことができま
す。
　但し、この機能は各 OS の持つファイルシステムの構造と挙動を
解析した上での機能なので、未解析のファイルシステムについては
ディレクトリ書込み機能は使えません。
　解析済のファイルシステムであるかどうかは、各ファイルシステ
ムのマウント情報からファイルシステムタイプを示す文字列を参照
し、その文字列から判断しています。
　FDclone でディレクトリ書込み機能をサポートしているファイル
システムは以下のとおりです。

	4.3	NEWS-OS 3,4.x
	4.2	SunOS 4.x
	ufs	SVR4, OSF/1, FreeBSD, NetBSD
	hfs	HP-UX, HI-UX
	ext2	Linux
	jfs	AIX
	efs	IRIX		(SGI 独自仕様)
	sysv	SVR3		(SystemV Rel.3 仕様)
	dg/ux	DG/UX		(SystemV Rel.3 仕様)

　これ以外の文字列で示されるタイプのファイルシステムでは、残
念ながらディレクトリ書込み機能を用いることはできません。
　もう少し正確に言うならば、上記以外のファイルシステムでも、
ディレクトリ書込みができる可能性がありますが、未確認のため安
全策をとって、ツールの機能としては殺してあります。

　もし、探求心のある方で、自分の持つファイルシステムでディレ
クトリ書込み機能が使えないことを悔しく思うならば、info.c の
中にある writablefs() を書換えてみることをお奨めします。
　ひょっとすると書込みに成功するかも知れませんし、失敗してデ
ィレクトリ内が目茶苦茶になってしまうかも知れません。
　もっと探求心のある方でしたら、自分でファイルシステムの構造
を解析し、ディレクトリ書込みアルゴリズム自体を書換えてみると
良いかも知れません。
　これらの改造の結果、ディレクトリ書込み機能のサポート対象が
増えるようでしたら、是非作者までご一報下さい。次回のリリース
に反映させて頂きます。

　一方、ファイルシステムのタイプとしては書込み機能が使えるは
ずなのに、OS 側の支障によってうまく機能が働かない場合があり
ます。
　もしくは、どんなファイルシステムであっても書込みできないよ
うな OS もあるでしょう。
　このような場合には、安全を最優先して、コンパイル時に識別子
UNKNOWNFS を定義しておいて下さい。

(補足) ディレクトリ書込みのアルゴリズム
	1.カレントディレクトリ内にテンポラリディレクトリ (仮
	  に TMP と呼ぶ) を作成。この時、TMP のファイル名は
	  先頭に並べたいファイルのファイル名と同じ長さにして
	  おく。
	2.TMP がディレクトリエントリ内で物理的に先頭にあるか
	  どうかチェック。
	3.TMP 以外の全ファイル (含ディレクトリ) を TMP 下に
	  移動。
	4.もし 2. で先頭になかった場合、TMP の名前をリネーム。
	  これで TMP はエントリ内の先頭にあることが保証され
	  る。
	5.並べたい順に、TMP 内のファイルを一つずつ元に移動。
	  但し、先頭に並べたいファイルだけは残しておく。
	6.ディレクトリのブロックサイズを考慮し、ブロック境界
	  に隙間ができる場合には、短いファイル名のダミーファ
	  イルを作成し隙間を埋める。
	7.ファイル移動が終ったら、TMP の名前をリネーム。これ
	  で TMP はエントリの最後尾にあり、エントリ先頭に空
	  き領域が確保される。
	8.先頭に持って並べたいファイルを TMP 内から元に戻す。
	9.TMP 及び 6. で作成されたダミーファイルを削除。
	10.完了。
註) ディレクトリファイルを直接操作している訳ではないので、デ
    ィレクトリサイズによってはかなり長い時間を要します。


3.ファイルシステム情報

　βテストで一番の難点だったのが、各 OS 毎に異なるファイルシ
ステムに関する情報取得法です。
　大雑把に分類すると、ファイルシステム情報に関して 5 種類、
マウント情報に関して 8 種類の手法を用意してあります。OS によ
っては、このうち複数の手法に対応できるものもあります。

　OS 側で複数の手法が用意されている場合、そのうちどれを用い
るかという難しい問題があります。というのも、手法の選択によっ
ては、その OS では不具合の生じる場合があるからです。
　一般には、1.で列挙されている順に優先順位をつけてもらえば良
いと思いますが、OS によってはこの優先順位は必ずしも正しくは
ないかも知れません。
　最終的には、可能な手法を全部試してみて、その中で最適なもの
を実装後に選択してやるしかないと思います。

　コンパイルすらできなかった場合は、文句なしにそれは選択ミス
です。コンパイルが成功したら、色々なディレクトリパスに対して
INFO_FILESYS (i) コマンドを実行してみて下さい。
　INFO_FILESYS コマンドの出力は、df(1) の出力とほぼ同じです。
丸め誤差を考慮しても明らかにおかしな値が出るようであれば、選
択ミスかも知れません。

　選択ミスによる出力値の異常は、2 つの原因が考えられます。
	1.マウントポイントを取り違えた。
	2.ファイルシステム情報の取得ミス。
　出力情報の中で、「ファイルシステム」や「マウントポイント」
の項目が正しくない場合には、マウント情報取得法に関する選択を
変えてみて下さい。
　また、これらの項目は正しいのに容量が正しくない場合には、フ
ァイルシステム情報に関する選択を変えてみて下さい。

　最悪の場合、どの選択をしても、正しい出力が得られない場合が
あります。その場合は諦めざるを得ません。
　但し、出力に誤りがあったとしても、FDclone の中ではこれらの
情報ミスは致命的な欠陥には結び付きません。INFO_FILESYS コマ
ンド以外には利用されないので、このコマンドさえ使わなければ支
障ありません。

　ただ、どの OS にも正しい情報取得法は用意されているはずです。
それを知っていれば、FDclone にその取得法を実装することが可能
ですので、もし対処法を講じられた場合は、作者までご一報下さい。
次回のリリースに反映します。


4.キーコード

　キーボードからの入力は、一般のキーであればそのキーの刻印の
文字を表す ASCII コードを受信することになりますが、各種機能
キーの場合には、キーボードは ESC で始まるシーケンスを吐きま
す。
　これらのシーケンスと ESC そのものの入力を正しく判断するた
めに、FDclone では ESC 受信後に 360ms 待って、後続の入力コー
ドがなければ ESC そのものの入力と見なしています。
　但し、この数値は作者周辺の環境で色々確認してみた際の値です
ので、絶対的な根拠は何もありません。この値でうまく動かない環
境があるようであれば、machine.h 内で WAITKEYPAD の値を 360ms
より大きい値で定義してみて下さい。

　また、キーシーケンスと実際のキーの対応表として、termcap ま
たは terminfo の記述を参照しています。記述がなかったキーにつ
いては、VT200 互換端末のキーマップをデフォルトとして用います。
　この対応が実際のキーボードの送信コードと合致していない場合、
そのキーの取得ができなくなります。そのような場合には termcap
や terminfo の登録を正しいものに改めることをお奨めします。


5.アーカイブブラウザの登録

　アーカイブブラウザを新規登録する場合には、.fdrc などにフォ
ーマット文字列を記述する必要があります。ここでは、マニュアル
に触れられていない具体例についてお話しします。
　フォーマット文字列の書式は下記のようになっています。

"t, b: f1, f2, f3, f4, f5, f6, f7, f8, f9 [: s1, ...]"

　t, b については、ほとんどのアーカイバについては回避できる
と思いますので、普通は共に 0 を指定します。
　アーカイブファイル情報以外にコピーライト表示などの余計な行
が表示されてしまう場合のみ、それぞれ、先頭行から、最終行から
の削除する行数を数値で指定して下さい。

　f1-f9 の記述は、単に、タイムスタンプ情報などが何フィールド
目にあるかを表しているだけです。
　フィールド番号だけでは表し切れない場合、表示情報範囲の前後
に当たる部分の文字を付記して、そのフィールド内でどの範囲に表
示されているかを指定します。
　以下に、ファイル情報の表示例と、それが第 1 フィールドにあ
った場合に `???' の部分を表す f? の記述例を挙げておきます。

???/xxxx	-> 1-'/'
xxxx/???	-> 1'/'
xx:???/xx	-> 1':'-'/'
xx/???xxx	-> 1'/'-3

　一番厄介なのが s1, s2 といった「強制セパレータ位置」に関す
る記述だと思います。
　普通のアーカイブ一覧では、ファイルの各情報は空白文字やタブ
文字で区切られているため、その区切りで分けられた範囲をフィー
ルドと見なします。
　しかし、一部のアーカイバでは、別々の情報が連続して表示され
ることがあります。次の例は、BSD 系の tar による出力例です。

rw-r--r--9999/999  17531 Aug  7 11:50 1995 main.c

　先頭のファイルモードを表す文字列と、その次のユーザ ID を表
す文字列との間に何の区切りもありません。このような場合、先頭
から 10 カラム目で仮想的にフィールドを区切るよう指示してやる
必要が生じます。
　これが「強制セパレータ位置」というパラメータになります。上
記の意味としては、s1 に 10 を記述することになります。以下に
この場合のフォーマット文字列を記しておきます。

0, 0: 1-9, 2-'/', 1'/', 2, 6, 3, 4, 5, 7: 10

　この「強制セパレータ位置」によって仮想的に設けられたパラメ
ータセパレータは、実際にその位置にセパレータがあった場合も正
常に機能します。
　例えば、上記の出力例ではユーザ ID が 9999 になっていますが、
root など 3 桁に満たないユーザ ID の場合では、ファイルモード
とユーザ ID の表示の間に空白文字が入ることになります。
　その場合でも、10 カラム目にセパレータ (この場合は仮想セパ
レータではなく空白文字による実セパレータ) があることには変わ
りはありませんので、動作に支障は生じません。

　ということならば、BSD 系以外の tar に関しても、s1=10 とい
う設定にしておいて構わないように思えますが、実際はそうとも限
りません。次の例は GNU tar による出力例です。

-rw-r--r-- 9999/999      17531 Aug  7 11:50 1995 main.c

　先頭のファイルモードを表す文字列の後ろに空白文字がついてい
る点で先の出力例と異なりますが、もう一つ相違点があります。フ
ァイルモード文字列が 10 桁ありますね。
　このため、セパレータの位置は 11 カラム目にあります。s1=10
の設定にしておくと、`-rw-r--r-' までを第 1 フィールド、続く
`-' を第 2 フィールドと見なしてしまいます。
　これでは、以降のフィールド番号が一つずつずれてしまいますの
で、正しく動作できません。この場合は、s1=11 にするか、「強制
セパレータ位置」に関する記述を削除するかしないといけません。
　元々空白文字によるセパレータがあるのですから、':' 以降は省
略して記述しないというのが順当でしょう。以下にこの場合のフォ
ーマット文字列を記しておきます。

0, 0: 1, 2-'/', 2'/', 3, 7, 4, 5, 6, 8


　なお、アーカイバによっては年表示や時刻表示ができなかったり、
これらを兼用していたりするものがあります。以下は lha による
出力例です。

drwxr-xr-x  9999/999         0 ****** Jun  8 12:04 demo/
-rw-r--r--  9999/999        49 100.0% Dec  8  1994 demo/Makefile

　このように、時刻フィールドと年フィールドが兼用され、タイム
スタンプの古いものでは時刻表示がありません。
　このような場合は、アーカイバブラウザの表示がおかしくなるこ
とを覚悟の上で、年情報と時刻情報の両方の項目に、同じフィール
ド番号を指定します。
　この場合、前者の例では 2012 年という年表示になり、後者の例
では 0:00 という時刻表示 (1994 時という時刻は存在し得ないた
め) になります。
　以下にこの場合のフォーマット文字列を記しておきます。

0, 0: 1, 2-'/', 2'/', 3, 7, 5, 6, 7, 8


6. フロッピードライブの登録

　システムに付属のフロッピーディスクドライブ内の MS-DOS フォ
ーマットのフロッピーを、FDclone 上から一般のファイルシステム
と同様に扱うためには、.fdrc などにそのドライブを登録してやる
必要があります。
　この登録のためには、まずフロッピーディスクドライブ用のドラ
イバが OS に組み込まれていることと、そのドライバアクセス用の
インタフェースがスペシャルファイルとして用意されていることが
必要です。
　詳細は OS によって異なりますが、fd(4) のマニュアルに詳しく
書かれている場合が多いようです。

　一般的な例ですが、一つの物理的なドライブに対し、複数のフォ
ーマットが対応されているケースが多いようです。この複数のフォ
ーマットは、自動識別される場合もありますし、スペシャルファイ
ル名によって分類されている場合もあります。
　前者の場合、ドライブ登録行のデバイスファイルには同じスペシ
ャルファイル名を記し、フォーマットのパラメータでそれぞれを区
別させます。
　後者の場合、ドライブ名は同じでもデバイスファイルにはそれぞ
れのフォーマットに応じたスペシャルファイル名を記しておく必要
があります。
　また、ここでは選ぶデバイスファイルは、できるだけ raw デバ
イスにしておいた方が良いでしょう。

　以下は SPARCsystems と NWS-3400シリーズの内蔵ドライブに関
する設定例です。

SPARC:
	A:	"/dev/rfd0c", 2, 18, 80		(1440KB	2HD)
	A:	"/dev/rfd0c", 2,  9, 80		(720KB	2DD)
	A:	"/dev/rfd0c", 2, 108, 80	(640KB	2DD)

NWS-3400:
	A:	"/dev/rfd00a", 2, 18, 80	(1440KB	2HD)
	A:	"/dev/rfd01a", 2,  9, 80	(720KB	2DD)
	A:	"/dev/rfd03a", 2,  8, 80	(640KB	2DD)

　これらの設定は、OS が同じでもマシンや構成が異なればそれに
依存しますので、コンパイル時の組込みで行なうよりも、共通設定
ファイルで行なった方がいいかも知れません。
　逆に、完成された FDclone のバイナリを使う可能性のあるマシ
ンがそれ一台だけであるならば、組込みでコンパイルしてしまう手
も有効です。
　組込みでコンパイルしたい場合は、dosdisk.c の中にある fdtype
という構造体配列の値を書き換えます。設定する要素は、.fdrc 等
での登録と全く同じです。
　但し、ドライブ名は "A:" といった文字列でなく、アルファベッ
ト 1 文字で表します。ここでは、必ず大文字にしておいて下さい。

　どのスペシャルファイルが、どのドライブのどういうフォーマッ
トを指しているかは、OS や機種に完全に依存しますので、各マニ
ュアルを参照するか、メーカに直接質問して下さい。
　配布パッケージでは、標準的な機種の内蔵ドライブに対する設定
を組込みで行なうようにしてありますが、これはインストールする
人間の判断で変更して下さい。

　尚、MS-DOS のファイル名に関する制限によるコンバートは、以
下のルールによって行なわれます。これは、BSD on Windows の仕
様と同じにしてあります。
	1.ファイル名が 8+3 文字を越える部分は削除。
	2.行頭または 2 つ目以降の . は $ に変更。
	3.任意の + は ` に変更。
	4.任意の , は ' に変更。
	5.任意の [ は & に変更。
　フロッピードライブのファイル名を FDclone から見る場合には、
上記 2-5 の逆変換が行なわれます。
