[FDclone に関するテクニカルノウハウ集]


1.機種依存性吸収のために用意されている識別子

　mashine.h の中や、make config で生成される config.h の中で
は、各種の識別子が定義されています。これらの識別子は、OS の
違いを吸収するために設けられています。
　自分の環境で、うまくコンパイルできない、どうもおかしな挙動
を示すというような場合には、これらの識別子を定義したり、定義
を取り消したりして調整して下さい。
　各識別子の意味を以下に列挙します。

SYSV
SVR4
BSD4
BSD43	各種 OS の元となるタイプを示します。SYSV, SVR4 は、
	mashine.h の後半で、OS 特有の定義のために参照されて
	いますが、BSD4, BSD43 は、参考として定義されているだ
	けなので、実際にはソース中で参照されていません。

OSTYPE	各 OS を表す識別子を定義しています。これも参考として
	定義しているだけです。

CODEEUC	漢字コードとして、EUC(Extended Unix Code) を用います。
	未定義の場合は ShiftJIS になります。インストール後の
	man ページや、ファイル名として用いる漢字コード等に影
	響します。
	画面表示に関しては、コンパイル後に動的に変更可能です。
TARUSESPACE
	tar(1) の t オプションの出力の際に、各行のファイルモ
	ード文字列 (Ex:rw-rw-rw-) の直後に必ず空白が入ってい
	る場合に定義します。BSD 系の OS では、空白がなく直後
	に UID/GID が続く場合が多いようです。GNU tar では空
	白が入ります。
	ここで仮に定義を間違えたとしても、.fdrc や /etc/fdrc
	の記述で動的に変更することは可能です。
CPP7BIT	cpp(1) が、漢字などの 8bit 文字を通すことができませ
	ん。
CCCOMMAND
	標準として用いるべき c コンパイラのフルパスを定義し
	ます。一部の OS では、BSD 版 cc と SYSV 版 cc が混在
	することがありますので、どちらかに統一しておきましょ
	う。未定義の場合には cc が用いられます。
EXTENDEDCCOPT
	cc(1) に与えるオプションを定義します。未定義の場合は
	"-O" が指定されます。"-O"(Optimize) に未対応の場合に
	は、ヌルを定義しておきましょう。
TERMCAPLIB
	tarmcap(5) ライブラリとしてリンクしなくてはならない
	ライブラリを定義します。未定義の場合は -ltermcap が
	指定されます。
REGEXPLIB
	正規表現ライブラリとしてリンクしなければならないライ
	ブラリがある場合定義します。
EXTENDLIB
	その他追加でリンクしなくてはならなrライブラリがある
	場合定義します。

UNKNOWNFS
	FDclone が想定している以外のファイルシステムを OS が
	採用しています。その他、ディレクトリ書込み機能がうま
	く実現できない場合にも、安全のため定義しておきます。
	詳細は 2. の項目を参照して下さい。

USELEAPCNT
	OS が、タイムゾーン情報として閏秒を採用しています。
NOVOID	void 型を用いることができません。
NOUID_T	uid_t, gid_t が <sys/types.h> で定義されていません。
DECLERRLIST
	大域変数 sys_errlist[] が <stdio.h> の中で宣言されて
	おり、ソースリスト中で改めて宣言する必要がありません。
PWNEEDERROR
	/lib/libPW.a をリンクする際に、大域変数 Error[] をソ
	ース中に用意しなくてはなりません。
NOERRNO	大域変数 errno が <errno.h> の中で宣言されていません。
NOFILEMODE
	ファイルモードを示す定数 S_IRUSR, S_IWUSR 等が <sys/
	stat.h> の中で定義されていません。
NOUNISTDH
	<unistd.h> が存在しません。
NOSTDLIBH
	<stdlib.h> が存在しません。
USESELECTH
	関数 select(2) を利用する際に必要な構造体 fd_set が、
	<sys/select.h> の中で定義されています。
USESYSDIRH
	ディレクトリファイルのブロックを示す定数 DEV_BSIZE
	が、<sys/dir.h> の中で定義されています。
USETIMEH
	構造体 tm が、<sys/types.h> や <sys/time.h> を参照す
	るだけでは定義されず、<time.h> が必要です。
USETERMIO
	端末インタフェースとして、termio 構造体を用います。
	未定義の場合には sgttyb 構造体を用います。
USEDIRECT
	構造体 dirent の代わりに direct を用います。
SYSVDIRENT
	構造体 dirent がメンバ d_namlen を持ちません。
HAVETIMEZONE
	大域変数 timezone が GMT からのオフセット値を表しま
	す。

(以下の 5 つは排他的です。同時に複数定義できません。)
USESTATVFSH
	ファイルシステム情報を得るために、<sys/statvfs.h> で
	宣言されている関数群を用います。
USESTATFSH
	ファイルシステム情報を得るために、<sys/statfs.h> で
	宣言されている関数群を用います。
USEVFSH
	ファイルシステム情報を得るために、<sys/vfs.h> で宣言
	されている関数群を用います。
USEMOUNTH
	ファイルシステム情報を得るために、<sys/mount.h> で宣
	言されている関数群を用います。
USEFSDATA
	ファイルシステム情報を得るために、構造体 fs_data を
	用いる関数群を用います。

USEFFSIZE
	構造体 statfs のメンバの中で、ファイルシステムのブロ
	ックサイズとして f_fsize を参照します。未定義の場合
	は f_bsize を参照します。
	USESTATVFSH, USEFSDATA を定義した場合は意味を持ちま
	せん。
STATFSARGS
	関数 statfs(2) の用いる引数の数を定義します。
	USESTATVFSH, USEFSDATA を定義した場合は意味を持ちま
	せん。

(以下の 8 つは排他的です。同時に複数定義できません。)
USEMNTENTH
	マウント情報を得るために、<mntent.h> で宣言されてい
	る関数群を用います。
USEMNTTABH
	マウント情報を得るために、<sys/mnttab.h> で宣言され
	ている関数群を用います。
USEGETFSSTAT
	マウント情報を得るために、関数 getfsstat(3) を用いま
	す。
USEMNTCTL
	マウント情報を得るために、関数 mntctl(3) を用います。
USEMNTINFOR
	マウント情報を得るために、関数 germntinfo_r(3) を用
	います。
USEMNTINFO
	マウント情報を得るために、関数 getmntinfo(3) を用い
	ます。
USEGETMNT
	マウント情報を得るために、関数 getmnt(3) を用います。
USEGETFSENT
	マウント情報を得るために、関数 getfsent(3) を用いま
	す。

(以下の 3 つは排他的です。同時に複数定義できません。)
USERE_COMP
	正規表現検索のために関数 re_comp(3) を用います。
USEREGCOMP
	正規表現検索のために関数 regcomp(3) を用います。
USEREGCMP
	正規表現検索のために関数 regcmp(3) を用います。

USERAND48
	乱数発生用関数として random(3) ではなく rand48(3) を
	用います。
USESETENV
	環境変数設定用関数として setenv(3) が使えます。
NOSELECT
	低レベル入出力関数 select(2) を使うことができません。
NOSTRSTR
	文字列関数 strstr(3) を使うことができません。
NOVSPRINTF
	書式付出力関数 vsprintf(3) を使うことができません。
USEUTIME
	タイムスタンプ設定関数として utimes(2) を用いられず、
	代わりに utime(3) を用います。
USEGETWD
	カレントディレクトリ検査関数として、getcwd(3) を用い
	られず、代わりに getwd(3) を用います。
SIGARGINT
	ソフトウェアシグナル関数 signal(3) の第 2 引数として、
	int 型を返す関数へのポインタが用いられます。

SENSEPERSEC
	1 秒間にキー入力を関知する回数を指定します。端末通信
	速度の遅い場合に定義すると良いでしょう。デフォルトは
	50 回です。
WAITKEYPAD
	ESC キーコードの入力を受けてから待つ時間です。端末通
	信速度の遅い場合に定義すると良いでしょう。デフォルト
	は 360ms です。


2.ディレクトリ書込み機能

　コマンド WRITE_DIR (w) を用いることで、FDclone の表示ディ
レクトリの並びをそのままファイルシステムに書込むことができま
す。
　但し、この機能は各 OS の持つファイルシステムの構造と挙動を
解析した上での機能なので、未解析のファイルシステムについては
ディレクトリ書込み機能は使えません。
　解析済のファイルシステムであるかどうかは、各ファイルシステ
ムのマウント情報からファイルシステムタイプを示す文字列を参照
し、その文字列から判断しています。
　FDclone でディレクトリ書込み機能をサポートしているファイル
システムは以下のとおりです。

	4.3	NEWS-OS 3,4.x
	4.2	SunOS 4.x
	ufs	SVR4, OSF/1, FreeBSD, NetBSD
	hfs	HP-UX, HI-UX
	ext2	Linux
	jfs	AIX
	efs	IRIX		(SGI 独自仕様)
	sysv	SVR3		(SystemV Rel.3 仕様)
	dg/ux	DG/UX		(SystemV Rel.3 仕様)

　これ以外の文字列で示されるタイプのファイルシステムでは、残
念ながらディレクトリ書込み機能を用いることはできません。
　もう少し正確に言うならば、上記以外のファイルシステムでも、
ディレクトリ書込みができる可能性がありますが、未確認のため安
全策をとって、ツールの機能としては殺してあります。

　もし、探求心のある方で、自分の持つファイルシステムでディレ
クトリ書込み機能が使えないことを悔しく思うならば、info.c の
中にある writablefs() を書換えてみることをお奨めします。
　ひょっとすると書込みに成功するかも知れませんし、失敗してデ
ィレクトリ内が目茶苦茶になってしまうかも知れません。
　もっと探求心のある方でしたら、自分でファイルシステムの構造
を解析し、ディレクトリ書込みアルゴリズム自体を書換えてみると
良いかも知れません。
　これらの改造の結果、ディレクトリ書込み機能のサポート対象が
増えるようでしたら、是非作者までご一報下さい。次回のリリース
に反映させて頂きます。

　一方、ファイルシステムのタイプとしては書込み機能が使えるは
ずなのに、OS 側の支障によってうまく機能が働かない場合があり
ます。
　もしくは、どんなファイルシステムであっても書込みできないよ
うな OS もあるでしょう。
　このような場合には、安全を最優先して、コンパイル時に識別子
UNKNOWNFS を定義しておいて下さい。

(補足) ディレクトリ書込みのアルゴリズム
	1.カレントディレクトリ内にテンポラリディレクトリ (仮
	  に TMP と呼ぶ) を作成。この時、TMP のファイル名は
	  先頭に並べたいファイルのファイル名と同じ長さにして
	  おく。
	2.TMP がディレクトリエントリ内で物理的に先頭にあるか
	  どうかチェック。
	3.TMP 以外の全ファイル (含ディレクトリ) を TMP 下に
	  移動。
	4.もし 2. で先頭になかった場合、TMP の名前をリネーム。
	  これで TMP はエントリ内の先頭にあることが保証され
	  る。
	5.並べたい順に、TMP 内のファイルを一つずつ元に移動。
	  但し、先頭に並べたいファイルだけは残しておく。
	6.ディレクトリのブロックサイズを考慮し、ブロック境界
	  に隙間ができる場合には、短いファイル名のダミーファ
	  イルを作成し隙間を埋める。
	7.ファイル移動が終ったら、TMP の名前をリネーム。これ
	  で TMP はエントリの最後尾にあり、エントリ先頭に空
	  き領域が確保される。
	8.先頭に持って並べたいファイルを TMP 内から元に戻す。
	9.TMP 及び 6. で作成されたダミーファイルを削除。
	10.完了。
註) ディレクトリファイルを直接操作している訳ではないので、デ
    ィレクトリサイズによってはかなり長い時間を要します。


3.ファイルシステム情報

　βテストで一番の難点だったのが、各 OS 毎に異なるファイルシ
ステムに関する情報取得法です。
　大雑把に分類すると、ファイルシステム情報に関して 5 種類、
マウント情報に関して 7 種類の手法を用意してあります。OS によ
っては、このうち複数の手法に対応できるものもあります。

　OS 側で複数の手法が用意されている場合、そのうちどれを用い
るかという難しい問題があります。というのも、手法の選択によっ
ては、その OS では不具合の生じる場合があるからです。
　一般には、1.で列挙されている順に優先順位をつけてもらえば良
いと思いますが、OS によってはこの優先順位は必ずしも正しくは
ないかも知れません。
　最終的には、可能な手法を全部試してみて、その中で最適なもの
を実装後に選択してやるしかないと思います。

　コンパイルすらできなかった場合は、文句なしにそれは選択ミス
です。コンパイルが成功したら、色々なディレクトリパスに対して
INFO_FILESYS (i) コマンドを実行してみて下さい。
　INFO_FILESYS コマンドの出力は、df(1) の出力とほぼ同じです。
丸め誤差を考慮しても明らかにおかしな値が出るようであれば、選
択ミスかも知れません。

　選択ミスによる出力値の異常は、2 つの原因が考えられます。
	1.マウントポイントを取り違えた。
	2.ファイルシステム情報の取得ミス。
　出力情報の中で、「ファイルシステム」や「マウントポイント」
の項目が正しくない場合には、マウント情報取得法に関する選択を
変えてみて下さい。
　また、これらの項目は正しいのに容量が正しくない場合には、フ
ァイルシステム情報に関する選択を変えてみて下さい。

　最悪の場合、どの選択をしても、正しい出力が得られない場合が
あります。その場合は諦めざるを得ません。
　但し、出力に誤りがあったとしても、FDclone の中ではこれらの
情報ミスは致命的な欠陥には結び付きません。INFO_FILESYS コマ
ンド以外には利用されないので、このコマンドさえ使わなければ支
障ありません。

　ただ、どの OS にも正しい情報取得法は用意されているはずです。
それを知っていれば、FDclone にその取得法を実装することが可能
ですので、もし対処法を講じられた場合は、作者までご一報下さい。
次回のリリースに反映します。


4.キーコード

　キーボードからの入力は、一般のキーであればそのキーの刻印の
文字を表す ASCII コードを受信することになりますが、各種機能
キーの場合には、キーボードは ESC で始まるシーケンスを吐きま
す。
　これらのシーケンスと ESC そのものの入力を正しく判断するた
めに、FDclone では ESC 受信後に 360ms 待って、後続の入力コー
ドがなければ ESC そのものの入力と見なしています。
　但し、この数値は作者周辺の環境で色々確認してみた際の値です
ので、絶対的な根拠は何もありません。この値でうまく動かない環
境があるようであれば、machine.h 内で WAITKEYPAD の値を 360ms
より大きい値で定義してみて下さい。

　また、キーシーケンスと実際のキーの対応表として、termcap ま
たは terminfo の記述を参照しています。記述がなかったキーにつ
いては、VT200 互換端末のキーマップをデフォルトとして用います。
　この対応が実際のキーボードの送信コードと合致していない場合、
そのキーの取得ができなくなります。そのような場合には termcap
や terminfo の登録を正しいものに改めることをお奨めします。
